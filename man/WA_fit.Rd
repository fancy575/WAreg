% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{WA_fit}
\alias{WA_fit}
\title{While-Alive Regression (WA) for Composite Endpoints}
\usage{
WA_fit(
  formula,
  data,
  id,
  cluster = NULL,
  knots,
  tau_grid,
  basis = c("il", "pl", "bz", "ns", "ms", "st", "tl", "tf"),
  degree = 1,
  link = c("log", "identity"),
  w_recur,
  w_term,
  ipcw = c("km", "cox"),
  ipcw_formula = ~1
)
}
\arguments{
\item{formula}{A \code{Surv(time, status) ~ RHS} formula. \code{time} and
\code{status} must exist in \code{data}. The RHS contains baseline
covariates (no explicit time-varying covariates here; time-variation is
induced via the chosen basis).}

\item{data}{Long-format data frame with one row per \emph{event/checkpoint}
per subject, containing \code{time}, \code{status}, \code{id}, optional
\code{cluster}, and RHS covariates.}

\item{id}{Character scalar; subject ID column name.}

\item{cluster}{Optional character scalar; cluster column name for CRT-robust
inference. If \code{NULL}, IID inference treats each subject as its own cluster.}

\item{knots}{Numeric vector (length \eqn{\ge 2}) specifying the basis
boundaries and optional interior knots that define the time basis shape.}

\item{tau_grid}{Numeric vector of evaluation times used to stack the
estimating equations. Independent of \code{knots}.}

\item{basis}{One of \code{"il","pl","bz","ns","ms","st","tl","tf"}:
interval-local (\code{"il"}), piecewise polynomial (\code{"pl"}),
B-spline (\code{"bz"}), natural spline (\code{"ns"}), M-spline
(\code{"ms"}, requires \pkg{splines2}), step (\code{"st"}), truncated
linear (\code{"tl"}), or time-fixed (\code{"tf"}).}

\item{degree}{Integer degree for bases that use it (e.g., \code{"bz"}, \code{"pl"}, \code{"ns"}, \code{"ms"}).}

\item{link}{Link function: \code{"log"} (default) or \code{"identity"}.}

\item{w_recur}{Numeric vector of weights for each recurrent event type. Its
length must match the number of recurrent \code{status} codes in
\code{data} (i.e., excluding \code{0} for censoring and the max code for terminal).}

\item{w_term}{Numeric scalar; weight for the terminal event.}

\item{ipcw}{IPCW method: \code{"km"} or \code{"cox"}.}

\item{ipcw_formula}{A one-sided formula specifying RHS covariates for the IPCW Cox model
when \code{ipcw = "cox"} (e.g., \code{~ x1 + x2}). Ignored for \code{ipcw = "km"}.}
}
\value{
An object of class \code{"WA"} with elements:
\itemize{
\item \code{est}: named coefficient vector.
\item \code{vcov}: cluster-robust variance matrix.
\item \code{se}: standard errors.
\item \code{converged}: logical.
\item \code{basis}, \code{degree}, \code{link}, \code{Z_cols},
\code{knots}, \code{tau_grid}, \code{id_var}, \code{cluster_var},
\code{w_recur}, \code{w_term}, \code{status_codes}, \code{formula}.
}
}
\description{
Fits the while-alive regression model targeting the while-alive loss rate
for composite endpoints with recurrent and terminal events. Time-varying
covariate effects are represented via user-chosen time bases (e.g., B-spline,
piecewise polynomial, interval-local). Robust inference supports
cluster-randomized trials (CRTs) via cluster-robust variance; if
\code{cluster = NULL}, IID (subject-as-cluster) variance is used.
}
\details{
The estimating equations solve \eqn{E[Z(t)\{L(t) - \mu_\beta(t)X_{\min}(t)\}V/G]=0}
over \code{tau_grid}, where \eqn{L(t)} is the weighted composite loss
(recurrent+terminal), \eqn{\mu_\beta(t)} the while-alive loss rate under the chosen
link, \eqn{X_{\min}(t) = \min(T, t)}, \eqn{V} the at-risk/terminal indicator, and
\eqn{G} the censoring survival modeled via \code{ipcw}.
}
\examples{
\dontrun{
# Example (non-running) using included 'crt_dt' long dataset
fit <- WA_fit(
  Surv(time, status) ~ intv + demo_sex_male + numchron,
  data     = crt_dt,
  id       = "screenid",
  cluster  = "practiceid",
  knots    = seq(0, 3.5, length.out = 6),
  tau_grid = seq(0, 3.5, length.out = 6),
  basis    = "bz", degree = 1, link = "log",
  w_recur  = c(1), w_term = 2,
  ipcw     = "cox", ipcw_formula = ~ demo_sex_male + numchron
)
s <- summary(fit)
}

}
