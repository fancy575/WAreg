# ======================================================================
# While-Alive Regression (WA) — Formula Interface for LONG data
# Main fit + S3 + Cross-Validation (cluster-aware)
# ======================================================================
# Imports used: survival, nleqslv, splines, splines2 (optional), dplyr, tidyr, ggplot2
# ======================================================================
# ---- Load required packages (install if missing) ----
req_pkgs  <- c("dplyr", "tidyr", "tibble", "ggplot2", "survival", "nleqslv", "splines", "MASS")
opt_pkgs  <- c("splines2")  # optional: only needed if you use basis = "ms"

need <- setdiff(req_pkgs, rownames(installed.packages()))
if (length(need)) install.packages(need, repos = "https://cloud.r-project.org")

need_opt <- setdiff(opt_pkgs, rownames(installed.packages()))
if (length(need_opt)) try(install.packages(need_opt, repos = "https://cloud.r-project.org"), silent = TRUE)

invisible(lapply(req_pkgs, require, character.only = TRUE))
invisible(lapply(intersect(opt_pkgs, rownames(installed.packages())), require, character.only = TRUE))


# ------------------------ Link helpers --------------------------------
.WA_link <- function(link = c("log","identity")) {
  link <- match.arg(link)
  if (link == "log") {
    list(link = link,
         linkinv = function(eta) exp(eta),
         dmu_deta = function(mu) mu)
  } else {
    list(link = link,
         linkinv = function(eta) pmax(eta, 0),
         dmu_deta = function(mu) as.numeric(mu >= 0))
  }
}

# ---------------- Surv parser for LONG recurrent-event data -----------
# Extracts names from Surv(time, status) and pulls columns directly.
# Returns time/status vectors and RHS model matrix (without intercept).
.WA_parse_formula <- function(formula, data) {
  tf <- terms(formula, data = data)
  # Surv(...) call is the second variable in 'variables' attribute
  lhs_call  <- attr(tf, "variables")[[2]]
  lhs_vars  <- all.vars(lhs_call)
  if (length(lhs_vars) < 2L)
    stop("Left side must be Surv(time, status).")
  time_name   <- lhs_vars[1]
  status_name <- lhs_vars[2]
  if (!time_name %in% names(data) || !status_name %in% names(data))
    stop("Columns specified in Surv() not found in data.")
  
  # Pull as-is from long data (no Surv evaluation)
  time_vec   <- data[[time_name]]
  status_vec <- data[[status_name]]
  
  # Coerce status to integer if needed but preserve original 0/1/2,... coding
  if (!is.integer(status_vec)) {
    if (is.numeric(status_vec)) {
      status_vec <- as.integer(status_vec)
    } else {
      # fallback for factor/character: map unique levels to integers but try to keep 0 if present
      if (any(suppressWarnings(!is.na(as.numeric(levels(as.factor(status_vec))))))) {
        status_vec <- as.integer(as.numeric(status_vec))
      } else {
        status_vec <- as.integer(as.factor(status_vec)) - 1L
      }
    }
  }
  
  # RHS model matrix (remove response and intercept)
  Xmm <- model.matrix(delete.response(tf), data = data)
  if (ncol(Xmm) > 0 && colnames(Xmm)[1] == "(Intercept)") {
    Xmm <- Xmm[, -1, drop = FALSE]
  }
  Z_cols <- colnames(Xmm)
  
  list(
    time_vec    = time_vec,
    status_vec  = status_vec,
    Xmm         = Xmm,
    Z_cols      = Z_cols,
    time_name   = time_name,
    status_name = status_name,
    tf          = tf
  )
}

# ------------------- Time-basis (two-letter codes) --------------------
# "bz": zero-anchored B-spline; "ns": zero-anchored natural spline
# "ms": M-spline (splines2); "st": step; "tl": truncated linear;
# "il": interval-local linear (STRIDE-style); "pl": piecewise poly degree p;
# "tf": time-fixed (no time variation)
.WA_time_basis <- function(t, knots,
                           basis = c("il","pl","bz","ns","ms","st","tl","tf"),
                           degree = 3,
                           include_intercept = FALSE) {
  basis <- match.arg(basis)
  t  <- as.numeric(t)
  ti <- sort(unique(as.numeric(knots)))
  stopifnot(length(ti) >= 2L)
  tmin <- min(ti); tmax <- max(ti)
  te   <- pmin(pmax(t, tmin), tmax)
  inter <- if (length(ti) > 2L) ti[-c(1L, length(ti))] else NULL
  newM <- function(nc) matrix(0, nrow = length(te), ncol = nc)
  
  if (basis == "bz") {
    B <- splines::bs(te, degree = degree, knots = inter,
                     Boundary.knots = c(tmin, tmax), intercept = include_intercept)
    tun <- (te - tmin) / pmax(tmax - tmin, .Machine$double.eps)
    out <- sweep(B, 1, tun, `*`)
    colnames(out) <- sprintf("t0_seg%d", seq_len(ncol(out))); return(out)
  }
  if (basis == "ns") {
    B <- splines::ns(te, knots = inter, Boundary.knots = c(tmin, tmax))
    tun <- (te - tmin) / pmax(tmax - tmin, .Machine$double.eps)
    out <- sweep(B, 1, tun, `*`)
    colnames(out) <- sprintf("t0_seg%d", seq_len(ncol(out))); return(out)
  }
  if (basis == "ms") {
    if (!requireNamespace("splines2", quietly = TRUE)) {
      warning("splines2 not installed; fallback to 'bz'.")
      return(.WA_time_basis(t, knots, basis = "bz", degree = degree,
                            include_intercept = include_intercept))
    }
    B <- splines2::mSpline(te, degree = degree, knots = inter,
                           Boundary.knots = c(tmin, tmax), intercept = include_intercept)
    colnames(B) <- sprintf("t0_seg%d", seq_len(ncol(B))); return(B)
  }
  if (basis == "st") {
    R <- length(ti) - 1L
    out <- newM(R); for (r in seq_len(R)) out[, r] <- as.numeric(te >= ti[r])
    colnames(out) <- sprintf("t0_seg%d", seq_len(R)); return(out)
  }
  if (basis == "tl") {
    R <- length(ti) - 1L
    out <- newM(R); for (r in seq_len(R)) out[, r] <- pmax(te - ti[r], 0)
    colnames(out) <- sprintf("t0_seg%d", seq_len(R)); return(out)
  }
  if (basis == "il") {  # interval-local linear within (kL, kR)
    R <- length(ti) - 1L
    out <- newM(R)
    for (r in seq_len(R)) {
      kL <- ti[r]; kR <- ti[r+1L]
      sel <- (te > kL) & (te < kR)
      out[sel, r] <- te[sel] - kL
    }
    colnames(out) <- sprintf("t0_seg%d", seq_len(R)); return(out)
  }
  if (basis == "pl") {  # piecewise poly degree p with interval indicator
    R <- length(ti) - 1L; P <- degree + 1L
    out <- newM(R*P); cn <- character(R*P); col <- 1L
    for (r in seq_len(R)) {
      kL <- ti[r]; kR <- ti[r+1L]
      ind <- (te > kL) & (te <= kR); base <- pmax(te - kL, 0)
      for (p in 0:degree) {
        out[ind, col] <- base[ind]^p
        cn[col] <- sprintf("t%d_seg%d", p, r); col <- col + 1L
      }
    }
    colnames(out) <- cn; return(out)
  }
  if (basis == "tf") {
    out <- matrix(1, nrow = length(te), ncol = 1)
    colnames(out) <- "t0_seg1"; return(out)
  }
  stop("Unknown basis.")
}

# --------------- Interact basis with covariates -----------------------
.WA_design_Z <- function(df, Z_cols, knots, basis, degree, include_intercept = FALSE) {
  stopifnot("tau" %in% names(df))
  B <- .WA_time_basis(df$tau, knots = knots, basis = basis,
                      degree = degree, include_intercept = include_intercept)
  for (z in Z_cols) {
    zv <- df[[z]]
    for (j in seq_len(ncol(B))) {
      nm <- sprintf("%s_%s", z, colnames(B)[j])
      df[[nm]] <- zv * B[, j]
    }
  }
  list(
    data = df,
    cov_pattern = paste0("^(", paste(Z_cols, collapse="|"), ")_t[0-9]+_seg[0-9]+$")
  )
}

# ------------------- Estimating equation U(β) -------------------------
.WA_ee <- function(beta, data, cov_pattern,
                   L_col="L", Dmin_col="X_min_tau", V_col="V_i_tau", G_col="G_X_min_tau",
                   link = c("log","identity")) {
  lf <- .WA_link(link)
  Zi_cols <- grep(cov_pattern, names(data), value = TRUE)
  if (length(Zi_cols) != length(beta)) stop("Length(beta) != design columns.")
  Zi  <- as.matrix(data[, Zi_cols, drop = FALSE])
  eta <- as.vector(Zi %*% beta)
  mu  <- lf$linkinv(eta)
  fac  <- data[[V_col]] / pmax(data[[G_col]], .Machine$double.eps)
  diff <- data[[L_col]] - mu * data[[Dmin_col]]
  colMeans(sweep(Zi, 1, fac * diff, `*`))
}

# --------------- Cluster-robust variance (IID if cluster=NULL) --------
.WA_var <- function(data, beta, cov_pattern,
                    L_col="L", Dmin_col="X_min_tau", V_col="V_i_tau", G_col="G_X_min_tau",
                    id_col, cluster_col = NULL, link = c("log","identity")) {
  lf <- .WA_link(link)
  Zi_cols <- grep(cov_pattern, names(data), value = TRUE)
  Zi <- as.matrix(data[, Zi_cols, drop = FALSE])
  p  <- ncol(Zi); nR <- nrow(Zi)
  
  Zb   <- as.vector(Zi %*% beta)
  mu   <- lf$linkinv(Zb)
  fac  <- data[[V_col]] / pmax(data[[G_col]], .Machine$double.eps)
  Xmin <- data[[Dmin_col]]
  Lval <- data[[L_col]]
  adjL <- Lval - mu * Xmin
  
  # A = E[ fac * mu * X * ZZ^T ]
  wA     <- fac * mu * Xmin
  A      <- (t(Zi) %*% (Zi * wA)) / nR
  
  # censoring grid & increments
  tgrid <- sort(unique(data$obs_T))
  m <- length(tgrid); if (m == 0L) stop("No obs_T")
  dt <- c(0, diff(tgrid))
  
  idx_T   <- findInterval(data$obs_T, tgrid, all.inside = TRUE)
  idx_tau <- findInterval(data$tau,   tgrid, all.inside = TRUE)
  
  counts_at <- tabulate(idx_T, nbins = m)
  Y_at_risk <- rev(cumsum(rev(counts_at)))
  
  idx_cens <- idx_T[data$Delta == 0L]
  dN_cens  <- tabulate(idx_cens, nbins = m)
  
  dLambda_C <- dN_cens / pmax(Y_at_risk, 1L)
  avg_risk  <- Y_at_risk / nR
  inv_avg   <- 1 / pmax(avg_risk, .Machine$double.eps)
  S_cum     <- cumsum(dLambda_C * inv_avg)
  A_i       <- ifelse(data$Delta == 0L, inv_avg[idx_T], 0)
  
  # dK_k(j)
  dK_mat <- (fac * adjL) * Zi
  j_idx  <- match(Xmin, tgrid, nomatch = 0L)
  
  sums_by_time <- matrix(0, nrow = m, ncol = p)
  if (any(j_idx > 0L)) {
    sums <- rowsum(dK_mat[j_idx > 0L, , drop = FALSE],
                   group = j_idx[j_idx > 0L], reorder = FALSE)
    sums_by_time[as.integer(rownames(sums)), ] <- sums
  }
  dK_by_time <- sums_by_time / nR
  
  # cumulative trapezoids
  cumtrap <- function(V) {
    Vprev <- rbind(V[1, , drop = FALSE], V[-m, , drop = FALSE])
    apply(dt * (Vprev + V) / 2, 2, cumsum)
  }
  T_dK  <- cumtrap(dK_by_time)
  T_SdK <- cumtrap(S_cum * dK_by_time)
  
  r    <- idx_tau
  kT   <- idx_T
  rmin <- pmin(r, kT)
  psi1 <- (as.integer(data$Delta == 0L) * inv_avg[kT]) - S_cum[pmin(1L, kT)]
  
  # pad
  T_dK0  <- rbind(0, T_dK)
  T_SdK0 <- rbind(0, T_SdK)
  S0     <- c(0, S_cum)
  dt0    <- c(0, dt)
  
  # clusters (CRT) or IID (subject as cluster)
  cl_raw <- if (!is.null(cluster_col) && cluster_col %in% names(data)) data[[cluster_col]] else data[[id_col]]
  cl_id   <- as.integer(factor(cl_raw))
  M       <- length(unique(cl_id))
  
  cluster_sums  <- matrix(0, nrow = M, ncol = p)
  cluster_sizes <- tabulate(cl_id, nbins = M)
  
  step <- 200000L
  for (a in seq(1L, nR, by = step)) {
    b <- min(a + step - 1L, nR)
    rr <- r[a:b]; kk <- kT[a:b]; rrmin <- rmin[a:b]; Ai <- A_i[a:b]
    
    Td_r  <- T_dK0[rr + 1L, , drop = FALSE]
    Td_kT <- T_dK0[kk + 1L, , drop = FALSE]
    TS_r  <- T_SdK0[rrmin + 1L, , drop = FALSE]
    
    half     <- 0.5 * dt0[kk + 1L]
    dK_kT    <- dK_by_time[kk, , drop = FALSE]
    halfTerm <- sweep(dK_kT, 1L, half, `*`)
    
    TermA <- sweep(Td_r - Td_kT + halfTerm, 1L, Ai * (rr >= kk), `*`)
    TermB <- TS_r + sweep(Td_r - Td_kT, 1L, S0[kk + 1L] * (rr > kk), `*`)
    integral <- TermA - TermB
    
    if (any(rr == 1L)) {
      mask1 <- (rr == 1L)
      dK1  <- matrix(dK_by_time[1L, ], nrow = sum(mask1), ncol = p, byrow = TRUE)
      integral[mask1, ] <- psi1[a:b][mask1] * dK1
    }
    
    Qblock <- dK_mat[a:b, , drop = FALSE] - integral
    sums_block <- rowsum(Qblock, group = cl_id[a:b], reorder = FALSE)
    rows <- as.integer(rownames(sums_block))
    cluster_sums[rows, ] <- cluster_sums[rows, ] + as.matrix(sums_block)
  }
  
  cluster_means <- sweep(cluster_sums, 1L, pmax(cluster_sizes, 1L), `/`)
  B <- crossprod(cluster_means) / M
  
  Ainv <- tryCatch(solve(A), error = function(e) {
    if (!requireNamespace("MASS", quietly = TRUE)) stop("Singular A and MASS not installed.")
    MASS::ginv(A)
  })
  Ainv %*% B %*% Ainv / M
}

# ---------------- Design at t for prediction --------------------------
.WA_design_at_t <- function(newdata, t, Z_cols, knots, basis, degree, include_intercept=FALSE) {
  B <- .WA_time_basis(t, knots = knots, basis = basis, degree = degree,
                      include_intercept = include_intercept)
  nb <- ncol(B)
  out_cols <- unlist(lapply(Z_cols, function(z) sprintf("%s_t0_seg%d", z, seq_len(nb))), use.names = FALSE)
  X <- matrix(0, nrow = nrow(newdata), ncol = length(out_cols),
              dimnames = list(NULL, out_cols))
  ctr <- 1L
  for (z in Z_cols) {
    blk <- outer(newdata[[z]], B)  # n x nb
    X[, ctr:(ctr+nb-1L)] <- blk
    ctr <- ctr + nb
  }
  X
}

# -------------------- IPCW helpers (for CV/PE) ------------------------
.WA_ipcw_fit <- function(subj, method = c("km","cox"), ipcw_formula = ~ 1) {
  method <- match.arg(method)
  if (method == "km") {
    sf <- survival::survfit(survival::Surv(time = subj$obs_T, event = 1 - subj$Delta) ~ 1)
    list(method = "km", times = sf$time, surv = sf$surv)
  } else {
    rhs <- paste(deparse(ipcw_formula[[2]]), collapse = "")
    cfit <- survival::coxph(stats::as.formula(paste0("Surv(obs_T, I(1-Delta)) ~ ", rhs)),
                            data = subj, ties = "breslow", x = TRUE, y = TRUE, model = FALSE)
    bh <- survival::basehaz(cfit, centered = FALSE)
    list(method = "cox", cfit = cfit, basehaz = bh, rhs = rhs)
  }
}

.WA_ipcw_predict_G <- function(ipcw_fit, X_min_tau, newdata = NULL) {
  if (identical(ipcw_fit$method, "km")) {
    stats::approx(ipcw_fit$times, ipcw_fit$surv, xout = X_min_tau,
                  method = "constant", f = 0,
                  yleft = 1, yright = tail(ipcw_fit$surv, 1))$y
  } else {
    bh <- ipcw_fit$basehaz
    Lambda0 <- stats::approxfun(bh$time, bh$hazard, method = "linear", rule = 2)
    mm <- stats::model.matrix(stats::as.formula(paste0("~ -1 + ", ipcw_fit$rhs)), data = newdata)
    beta <- stats::coef(ipcw_fit$cfit)
    if (length(beta)) mm <- mm[, names(beta), drop = FALSE]
    lp <- if (length(beta)) drop(mm %*% beta) else 0
    pmax(exp(-Lambda0(X_min_tau) * exp(lp)), 0)
  }
}

# ======================================================================
# MAIN USER FUNCTION: WA_fit
# ======================================================================
WA_fit <- function(formula,
                   data,
                   id,                 # subject id column name (string)
                   cluster = NULL,     # optional cluster column for CRT-robust SEs
                   # basis + time
                   knots,              # basis shape (boundaries + interior), length >= 2
                   tau_grid,           # τ-stacking grid (independent of knots)
                   basis   = c("il","pl","bz","ns","ms","st","tl","tf"),
                   degree  = 1,
                   link    = c("log","identity"),
                   # weights
                   w_recur,
                   w_term,
                   # IPCW
                   ipcw = c("km","cox"),
                   ipcw_formula = ~ 1) {
  
  basis <- match.arg(basis)
  link  <- match.arg(link)
  ipcw  <- match.arg(ipcw)
  
  # --- robust Surv/time/status parsing on LONG data ---
  par <- .WA_parse_formula(formula, data)
  time_vec   <- par$time_vec
  status_vec <- par$status_vec
  Xmm        <- par$Xmm
  Z_cols     <- par$Z_cols
  if (length(Z_cols) == 0L) stop("No covariates specified on RHS.")
  
  if (!id %in% names(data)) stop("id column not found in data.")
  if (!is.null(cluster) && !cluster %in% names(data)) stop("cluster column not found in data.")
  
  # build working df with standardized internal column names
  Z_df <- as.data.frame(Xmm); names(Z_df) <- Z_cols
  dat <- data.frame(hold=1:length(time_vec))
  dat$.time   <- time_vec
  dat$.status <- status_vec
  dat$.id     <- data[[id]]
  if(!is.null(cluster)){
    dat$.cluster <- data[[cluster]]
  }else{
    dat$.cluster <- data[[id]]
    
  }
  dat <- cbind(dat, Z_df)
  dat <- dat[,-1]
  dat <- dat %>% dplyr::select(where(~ !any(is.na(.))))
  
  # status coding: 0=censor; max=status terminal; middle= recurrent types
  ustat <- sort(unique(dat$.status))
  if (!any(ustat == 0L)) stop("Status must include 0 for censoring.")
  s_max <- max(ustat, na.rm = TRUE)
  rec_types <- setdiff(ustat, c(0L, s_max))
  if (length(w_recur) != length(rec_types)) {
    stop("Length(w_recur) must equal # recurrent event types (status in {",
         paste(rec_types, collapse=","), "}).")
  }
  
  # subject snapshot (obs_T, terminal indicator Δ)
  subj <- dat %>%
    dplyr::group_by(.id,.cluster) %>%
    dplyr::summarise(
      dplyr::across(dplyr::all_of(Z_cols), ~ dplyr::first(.x)),
      obs_T  = max(.time, na.rm = TRUE),
      Delta  = {
        idx <- which.max(.time)
        as.integer(.status[idx] == s_max)
      },
      .groups = "drop"
    )
  
  # τ expansion
  expanded <- subj %>%
    tidyr::crossing(tau = tau_grid) %>%
    dplyr::mutate(
      X_min_tau = pmin(obs_T, tau),
      V_i_tau   = as.integer((obs_T <= tau) & (Delta == 1L)) + as.integer(obs_T > tau),
      N_term_tau= as.integer((obs_T <= tau) & (Delta == 1L))
    )
  
  # IPCW (censoring survival)
  if (ipcw == "km") {
    km_c <- survival::survfit(survival::Surv(time = subj$obs_T, event = 1 - subj$Delta) ~ 1)
    expanded$G_X_min_tau <- approx(x = km_c$time, y = km_c$surv,
                                   xout = expanded$X_min_tau, method = "constant", f = 0,
                                   yleft = 1, yright = tail(km_c$surv, 1))$y
  } else {
    rhs <- paste(deparse(ipcw_formula[[2]]), collapse = "")
    cfit <- survival::coxph(stats::as.formula(paste0("Surv(obs_T, I(1-Delta)) ~ ", rhs)),
                            data = subj, ties = "breslow", x = TRUE, y = TRUE, model = FALSE)
    bh <- survival::basehaz(cfit, centered = FALSE)
    Lambda0 <- stats::approxfun(bh$time, bh$hazard, method = "linear", rule = 2)
    mm <- stats::model.matrix(stats::as.formula(paste0("~ -1 + ", rhs)), data = subj)
    beta_c <- stats::coef(cfit)
    if (length(beta_c)) mm <- mm[, names(beta_c), drop = FALSE]
    lp <- if (length(beta_c)) drop(mm %*% beta_c) else 0
    subj$lp_cens <- lp
    expanded <- dplyr::left_join(expanded, subj[, c(".id", "lp_cens")], by = c(".id" = ".id"))
    expanded$G_X_min_tau <- exp(-Lambda0(expanded$X_min_tau) * exp(expanded$lp_cens))
    expanded$G_X_min_tau[!is.finite(expanded$G_X_min_tau)] <- 0
  }
  
  # recurrent counts up to X_min_tau (for each type)
  recs <- dat %>%
    dplyr::filter(.status %in% c(rec_types, s_max)) %>%
    dplyr::select(.id, .status, .time)
  
  grid <- expanded %>% dplyr::select(.id, tau, X_min_tau)
  
  counts <- recs %>%
    dplyr::right_join(grid, by = ".id", relationship = "many-to-many") %>%
    dplyr::filter(.time <= X_min_tau) %>%
    dplyr::group_by(.id, tau, X_min_tau, .status) %>%
    dplyr::summarise(n = dplyr::n(), .groups = "drop")
  
  if (nrow(counts)) {
    counts_wide <- tidyr::pivot_wider(
      counts, id_cols = c(.id, tau, X_min_tau),
      names_from = .status, values_from = n, values_fill = 0L,
      names_prefix = "N_"
    )
    expanded <- dplyr::left_join(expanded, counts_wide,
                                 by = c(".id" = ".id", "tau" = "tau", "X_min_tau" = "X_min_tau"))
  }
  for (s in rec_types) {
    nm <- paste0("N_", s)
    if (!nm %in% names(expanded)) expanded[[nm]] <- 0L
  }
  
  # Loss L(τ)
  L_recur <- 0
  for (j in seq_along(rec_types)) L_recur <- L_recur + w_recur[j] * expanded[[paste0("N_", rec_types[j])]]

  expanded$L <- L_recur + w_term * expanded$N_term_tau
  
  expanded$L <- ifelse(is.na(expanded$L),0,expanded$L)
  
  # design (knots control basis shape; independent from tau_grid)
  tb <- .WA_design_Z(expanded, Z_cols = Z_cols, knots = knots,
                     basis = basis, degree = degree, include_intercept = FALSE)
  expanded <- tb$data
  cov_pat  <- tb$cov_pattern
  
  # solve U(β)=0
  p <- length(grep(cov_pat, names(expanded)))
  beta_init <- rep(0, p)
  sol <- nleqslv::nleqslv(
    x  = beta_init,
    fn = .WA_ee,
    data = expanded,
    cov_pattern = cov_pat,
    L_col="L", Dmin_col="X_min_tau", V_col="V_i_tau", G_col="G_X_min_tau",
    link = link,
    method = "Broyden"
  )
  if (sol$termcd > 3) warning("WA_fit: nleqslv may not have converged (termcd=", sol$termcd, ").")
  beta_hat <- sol$x
  
  # variance
  V <- .WA_var(
    data = expanded, beta = beta_hat, cov_pattern = cov_pat,
    L_col="L", Dmin_col="X_min_tau", V_col="V_i_tau", G_col="G_X_min_tau",
    id_col = ".id", cluster_col = if (is.null(cluster)) NULL else ".cluster",
    link = link
  )
  
  beta_names <- grep(cov_pat, names(expanded), value = TRUE)
  names(beta_hat) <- beta_names
  dimnames(V)     <- list(beta_names, beta_names)
  
  structure(list(
    call        = match.call(),
    est         = beta_hat,
    vcov        = V,
    se          = sqrt(pmax(diag(V), 0)),
    converged   = (sol$termcd <= 3),
    # metadata
    basis       = basis,
    degree      = degree,
    link        = link,
    Z_cols      = Z_cols,
    knots       = knots,
    tau_grid    = tau_grid,
    id_var      = id,
    cluster_var = cluster,
    w_recur     = w_recur,
    w_term      = w_term,
    status_codes= list(recurrent = rec_types, terminal = s_max, censor = 0),
    formula     = formula
  ), class = "WA")
}

# ======================================================================
# S3 methods: print / summary / predict / plot
# ======================================================================
print.WA <- function(x, ...) {
  cat("While-Alive Regression (WA)\n")
  cat("  basis:", x$basis, " degree:", x$degree, " link:", x$link, "\n")
  cat("  #coef:", length(x$est), " converged:", isTRUE(x$converged), "\n")
  invisible(x)
}

summary.WA <- function(object, ...) {
  coeftab <- data.frame(
    coef = object$est,
    se   = object$se,
    z    = ifelse(object$se > 0, object$est/object$se, NA_real_),
    row.names = names(object$est)
  )
  res <- list(
    basis = object$basis,
    degree = object$degree,
    link = object$link,
    knots = object$knots,
    tau_grid = object$tau_grid,
    status_codes = object$status_codes,
    w_recur = object$w_recur,
    w_term  = object$w_term,
    coef  = coeftab
  )
  class(res) <- "summary.WA"
  res
}

print.summary.WA <- function(x, ...) {
  cat("While-Alive Regression summary\n")
  cat("  basis:", x$basis, " degree:", x$degree, " link:", x$link, "\n")
  cat("  knots:", paste(format(x$knots), collapse = ", "), "\n")
  cat("  τ-grid length:", length(x$tau_grid), "\n")
  cat("  status codes: recurrent={", paste(x$status_codes$recurrent, collapse=","), "}, terminal=", x$status_codes$terminal, ", censor=0\n", sep = "")
  cat("  weights: recur=", paste(x$w_recur, collapse=","), " terminal=", x$w_term, "\n\n", sep="")
  print(x$coef)
  invisible(x)
}

predict.WA <- function(object, newdata, t_seq, level = 0.95, ...) {
  stopifnot(!is.null(object$est), !is.null(object$vcov))
  V  <- object$vcov
  lf <- .WA_link(object$link)
  
  # Rebuild RHS design from the same RHS as the fit, no Surv eval
  tf <- terms(object$formula, data = newdata)
  Xmm <- model.matrix(delete.response(tf), data = newdata)
  if (ncol(Xmm) > 0 && colnames(Xmm)[1] == "(Intercept)")
    Xmm <- Xmm[, -1, drop = FALSE]
  Z_cols <- colnames(Xmm)
  if (length(Z_cols) == 0L) stop("newdata lacks covariates specified in the model formula.")
  Z_df <- as.data.frame(Xmm)
  
  zcrit <- stats::qnorm(0.5 + level/2)
  rows <- vector("list", length(t_seq))
  
  for (i in seq_along(t_seq)) {
    X <- .WA_design_at_t(Z_df, t_seq[i], Z_cols, object$knots, object$basis, object$degree)
    beta_ord <- object$est[colnames(X)]
    eta <- as.vector(X %*% beta_ord)
    mu  <- lf$linkinv(eta)
    
    VX <- X %*% V[colnames(X), colnames(X), drop = FALSE]
    var_eta <- rowSums(VX * X)
    se_eta  <- sqrt(pmax(var_eta, 0))
    
    if (object$link == "log") {
      lb <- mu * exp(-zcrit * se_eta)
      ub <- mu * exp( zcrit * se_eta)
    } else {
      lb <- pmax(mu - zcrit*se_eta, 0)
      ub <- pmax(mu + zcrit*se_eta, 0)
    }
    rows[[i]] <- data.frame(id = seq_len(nrow(newdata)), t = t_seq[i],
                            mu = mu, lb = lb, ub = ub)
  }
  do.call(rbind, rows)
}

plot.WA <- function(x, newdata, t_seq, id = 1,
                    mode = c("wa","cov"),
                    covariate = NULL,
                    ylab_wa = "While-alive loss rate",
                    ylab_cov = NULL,
                    xlab = "Time",
                    level = 0.95,
                    smooth = FALSE,       # NEW
                    span = 0.30,          # NEW (only used if smooth=TRUE)
                    ...) {
  mode <- match.arg(mode)
  
  # ---- rebuild RHS design like predict.WA() ----
  tf  <- terms(x$formula, data = newdata)
  Xmm <- model.matrix(delete.response(tf), data = newdata)
  if (ncol(Xmm) > 0 && colnames(Xmm)[1] == "(Intercept)")
    Xmm <- Xmm[, -1, drop = FALSE]
  Z_cols <- colnames(Xmm)
  if (length(Z_cols) == 0L) stop("newdata lacks covariates specified in the model formula.")
  if (id < 1 || id > nrow(newdata)) stop("`id` out of range for `newdata`.")
  
  # small helper: optionally smooth columns y, ymin, ymax in data.frame df by LOESS
  maybe_smooth <- function(df, y, ymin, ymax) {
    if (!smooth) return(df)
    lo  <- stats::loess(stats::as.formula(paste0(y,    "~ t")), data = df, span = span)
    lol <- stats::loess(stats::as.formula(paste0(ymin, "~ t")), data = df, span = span)
    lou <- stats::loess(stats::as.formula(paste0(ymax, "~ t")), data = df, span = span)
    df[[y]]    <- stats::predict(lo)
    df[[ymin]] <- stats::predict(lol)
    df[[ymax]] <- stats::predict(lou)
    df
  }
  
  if (mode == "wa") {
    pred <- predict.WA(x, newdata = newdata, t_seq = t_seq, level = level)
    d <- pred[pred$id == id, , drop = FALSE]
    d <- maybe_smooth(d, y = "mu", ymin = "lb", ymax = "ub")
    return(
      ggplot2::ggplot(d, ggplot2::aes(x = t, y = mu)) +
        ggplot2::geom_line(linewidth = 0.6) +
        ggplot2::geom_ribbon(ggplot2::aes(ymin = lb, ymax = ub), alpha = 0.2) +
        ggplot2::labs(x = xlab, y = ylab_wa) +
        ggplot2::theme_minimal(base_size = 12) +
        ggplot2::theme(panel.grid.minor = ggplot2::element_blank())
    )
  }
  
  # ---- mode: covariate effect f_cov(t) using the SAME basis as in fit ----
  if (is.null(covariate) || !(covariate %in% Z_cols))
    stop("Provide a valid `covariate` name present in the model RHS.")
  if (is.null(ylab_cov)) ylab_cov <- paste0("Effect of ", covariate, " on η(t)")
  
  want <- grep(paste0("^", covariate, "_t0_seg[0-9]+$"), names(x$est), value = TRUE)
  if (!length(want)) stop("No time-basis coefficients found for ", covariate)
  seg <- as.integer(sub(".*_seg([0-9]+)$", "\\1", want))
  ord <- order(seg); want <- want[ord]; seg <- seg[ord]
  
  build_basis_match <- function(inc_int) {
    B <- .WA_time_basis(
      t      = t_seq,
      knots  = x$knots,
      basis  = x$basis,
      degree = x$degree,
      include_intercept = inc_int
    )
    colnames(B) <- sprintf("t0_seg%d", seq_len(ncol(B)))
    need_names <- sprintf("t0_seg%d", seg)
    idx <- match(need_names, colnames(B))
    list(B = B, idx = idx, ok = !any(is.na(idx)))
  }
  
  try1 <- build_basis_match(FALSE)
  if (try1$ok) { Bfull <- try1$B; idx <- try1$idx } else {
    try2 <- build_basis_match(TRUE)
    if (!try2$ok) stop("Basis/coef mismatch. Check basis/degree/knots vs fit.")
    Bfull <- try2$B; idx <- try2$idx
  }
  
  Bz <- Bfull[, idx, drop = FALSE]
  b  <- as.numeric(x$est[want])
  V  <- as.matrix(x$vcov[want, want, drop = FALSE])
  
  beta_hat <- as.vector(Bz %*% b)
  var_hat  <- rowSums((Bz %*% V) * Bz)
  var_hat  <- pmax(var_hat, 0)
  zcrit    <- stats::qnorm(0.5 + level/2)
  lb <- beta_hat - zcrit * sqrt(var_hat)
  ub <- beta_hat + zcrit * sqrt(var_hat)
  
  df <- data.frame(t = t_seq, eff = beta_hat, lb = lb, ub = ub)
  df <- maybe_smooth(df, y = "eff", ymin = "lb", ymax = "ub")
  
  ggplot2::ggplot(df, ggplot2::aes(x = t, y = eff)) +
    ggplot2::geom_line(linewidth = 0.6) +
    ggplot2::geom_ribbon(ggplot2::aes(ymin = lb, ymax = ub), alpha = 0.2) +
    ggplot2::labs(x = xlab, y = ylab_cov) +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),
                   legend.position = "none")
}


# ======================================================================
# Prediction Error functional used in CV (matches estimating eqn target)
# ======================================================================
WA_PE <- function(fit,               # WA object (trained on TRAIN fold)
                  formula,           # same formula used in WA_fit
                  data_test,         # TEST fold (long)
                  id,                # id column name (string)
                  w_recur, w_term,   # weights (match TEST status coding)
                  ipcw_fit,          # IPCW fit computed on TRAIN subjects
                  tau_grid = fit$tau_grid) {
  
  # Build a minimal, de-duplicated long test frame
  par_pe      <- .WA_parse_formula(formula, data_test)
  Xmm         <- par_pe$Xmm
  Z_cols      <- par_pe$Z_cols
  time_name   <- par_pe$time_name
  status_name <- par_pe$status_name
  
  if (length(Z_cols) == 0L) stop("No covariates on RHS for TEST data.")
  
  # Build a clean long test frame (no vector injection)
  test_df <- dplyr::bind_cols(
    tibble::tibble(
      .id     = data_test[[id]],
      .time   = data_test[[time_name]],
      .status = as.integer(data_test[[status_name]])
    ),
    as.data.frame(Xmm)  # columns are exactly Z_cols
  )
  
  # subject-level snapshot without duplicating columns
  s_max     <- max(test_df$.status, na.rm = TRUE)
  rec_types <- setdiff(sort(unique(test_df$.status)), c(0L, s_max))
  subj <- test_df %>%
    dplyr::group_by(.id) %>%
    dplyr::summarise(
      dplyr::across(dplyr::all_of(Z_cols), ~ dplyr::first(.x)),
      obs_T = max(.time, na.rm = TRUE),
      Delta = {
        i_last <- which.max(.time)
        as.integer(.status[i_last] == s_max)
      },
      .groups = "drop"
    )
  
  uid <- subj$.id
  int_each <- numeric(length(uid)); names(int_each) <- as.character(uid)
  eps <- .Machine$double.eps
  scalar_prev <- NULL; tau_prev <- NULL
  
  # τ loop
  for (tau in tau_grid) {
    X_min_tau <- pmin(subj$obs_T, tau)
    V_i_tau   <- as.integer((subj$obs_T <= tau) & (subj$Delta == 1L)) + as.integer(subj$obs_T > tau)
    
    # recurrent counts up to min(τ, obs_T)
    recs <- test_df %>%
      dplyr::filter(.status %in% c(rec_types, s_max)) %>%
      dplyr::select(.id, .status, .time)
    
    grid <- tibble::tibble(.id = uid, tau = tau, X_min_tau = X_min_tau)
    
    counts <- recs %>%
      dplyr::right_join(grid, by = ".id", relationship = "many-to-many") %>%
      dplyr::filter(.time <= X_min_tau) %>%
      dplyr::group_by(.id, tau, X_min_tau, .status) %>%
      dplyr::summarise(n = dplyr::n(), .groups = "drop")
    
    if (nrow(counts)) {
      counts_wide <- tidyr::pivot_wider(
        counts, id_cols = c(.id, tau, X_min_tau),
        names_from = .status, values_from = n, values_fill = 0L,
        names_prefix = "N_"
      )
    } else {
      counts_wide <- grid
    }
    
    tmp <- subj %>%
      dplyr::mutate(tau = tau, X_min_tau = X_min_tau, V_i_tau = V_i_tau) %>%
      dplyr::left_join(counts_wide, by = c(".id","tau","X_min_tau")) %>%
      { . <- .; for (s in rec_types) if (!paste0("N_",s) %in% names(.)) .[[paste0("N_",s)]] <- 0L; . } %>%
      dplyr::mutate(N_term_tau = as.integer((obs_T <= tau) & (Delta == 1L)))
    
    # Loss L(τ)
    L_recur <- 0
    for (j in seq_along(rec_types)) L_recur <- L_recur + w_recur[j] * tmp[[paste0("N_", rec_types[j])]]
    tmp$L <- L_recur + w_term * tmp$N_term_tau
    
    # IPCW G(X_min_tau) from TRAIN
    tmp$G_X_min_tau <- .WA_ipcw_predict_G(ipcw_fit, tmp$X_min_tau, newdata = tmp)
    
    # μ_i(τ) from TRAIN coefficients/basis
    Xnew <- as.data.frame(subj[, Z_cols, drop = FALSE])
    X <- .WA_design_at_t(Xnew, tau, Z_cols, fit$knots, fit$basis, fit$degree)
    beta_ord <- fit$est[colnames(X)]
    eta <- as.vector(X %*% beta_ord)
    lf  <- .WA_link(fit$link)
    mu  <- lf$linkinv(eta)
    
    resid <- tmp$L - mu * tmp$X_min_tau
    fac   <- tmp$V_i_tau / pmax(tmp$G_X_min_tau, eps)
    scalar_now <- fac * (resid^2)
    
    if (is.null(scalar_prev)) {
      dt <- tau
      int_each <- int_each + (scalar_now) * dt / 2
    } else {
      dt <- tau - tau_prev
      int_each <- int_each + (scalar_now + scalar_prev) * dt / 2
    }
    scalar_prev <- scalar_now; tau_prev <- tau
  }
  
  sum(int_each, na.rm = TRUE)
}

# ======================================================================
# Cross-Validation: grid search over basis/degree/knots/link
# ======================================================================
WA_cv <- function(formula,
                  data,
                  id,
                  cluster = NULL,
                  # search grids
                  basis_set   = c("il","pl","bz"),
                  degree_vec  = 1:2,
                  n_int_vec   = c(0, 2, 4),
                  knot_scheme = c("equidist","quantile"),
                  link_set    = c("log"),
                  # time ranges + τ-grid
                  time_range  = NULL,
                  tau_grid    = NULL,
                  # weights
                  w_recur,
                  w_term,
                  # IPCW
                  ipcw        = c("cox","km"),
                  ipcw_formula = ~ 1,
                  # CV folds
                  K = 5, seed = 1L,
                  # progress
                  verbose = TRUE) {
  knot_scheme <- match.arg(knot_scheme)
  ipcw <- match.arg(ipcw)
  
  # infer time range from data (no Surv evaluation)
  par_cv <- .WA_parse_formula(formula, data)
  t_obs  <- par_cv$time_vec
  if (is.null(time_range)) {
    tmin <- 0
    tmax <- max(t_obs, na.rm = TRUE)
  } else {
    tmin <- time_range[1]; tmax <- time_range[2]
  }
  if (is.null(tau_grid)) {
    tau_grid <- seq(tmin, tmax - 1e-6, length.out = 150)
  }
  
  # fold assignment (cluster-aware)
  set.seed(seed)
  if (!is.null(cluster) && cluster %in% names(data)) {
    keys <- unique(data[[cluster]])
    fold_ids <- sample(rep_len(seq_len(K), length(keys)))
    names(fold_ids) <- as.character(keys)
    data$.fold <- fold_ids[as.character(data[[cluster]])]
  } else {
    keys <- unique(data[[id]])
    fold_ids <- sample(rep_len(seq_len(K), length(keys)))
    names(fold_ids) <- as.character(keys)
    data$.fold <- fold_ids[as.character(data[[id]])]
  }
  
  # make knots from # interior knots
  make_knots <- function(n_int) {
    if (n_int <= 0) return(c(tmin, tmax))
    if (knot_scheme == "equidist") {
      inter <- seq(tmin, tmax, length.out = n_int + 2L)[-c(1, n_int + 2L)]
    } else {
      qs <- seq(0, 1, length.out = n_int + 2L)[-c(1, n_int + 2L)]
      inter <- as.numeric(stats::quantile(t_obs, probs = qs, na.rm = TRUE))
    }
    sort(unique(c(tmin, inter, tmax)))
  }
  
  # ---- progress setup ----
  n_cfg  <- length(basis_set) * length(degree_vec) * length(n_int_vec) * length(link_set)
  total_steps <- n_cfg * K
  step <- 0L
  if (verbose) {
    pb <- utils::txtProgressBar(min = 0, max = total_steps, style = 3)
    on.exit(try(close(pb), silent = TRUE), add = TRUE)
  }
  bump <- function(extra_msg = NULL) {
    if (verbose) {
      step <<- step + 1L
      utils::setTxtProgressBar(pb, step)
      if (!is.null(extra_msg)) {
        # light, optional line after bar ticks; keep it sparse to stay readable
        cat(sprintf("\n%s\n", extra_msg)); flush.console()
      }
    }
  }
  
  results <- list(); idx <- 1L
  
  for (bs in basis_set) {
    for (deg in degree_vec) {
      for (nk in n_int_vec) {
        knots <- make_knots(nk)
        for (lnk in link_set) {
          
          if (verbose) {
            cat(sprintf(
              "\n[Config] basis=%s, degree=%s, n_int=%s, link=%s\n",
              bs, deg, nk, lnk
            ))
            flush.console()
          }
          
          PE_sum <- 0
          
          for (k in seq_len(K)) {
            if (verbose) {
              cat(sprintf("  - Fold %d/%d ... ", k, K)); flush.console()
            }
            
            train <- data[data$.fold != k, , drop = FALSE]
            test  <- data[data$.fold == k, , drop = FALSE]
            
            # fit on TRAIN
            fit_k <- WA_fit(
              formula    = formula,
              data       = train,
              id         = id,
              cluster    = cluster,
              knots      = knots,
              tau_grid   = tau_grid,
              basis      = bs,
              degree     = deg,
              link       = lnk,
              w_recur    = w_recur,
              w_term     = w_term,
              ipcw       = ipcw,
              ipcw_formula = ipcw_formula
            )
            
            # IPCW fit on TRAIN subjects for PE on TEST (keep RHS covariates)
            par_tr <- .WA_parse_formula(formula, train)
            tr_df <- train %>%
              dplyr::mutate(
                .id     = .data[[id]],
                .time   = par_tr$time_vec,
                .status = as.integer(par_tr$status_vec)
              ) %>%
              dplyr::group_by(.id) %>%
              dplyr::summarise(
                dplyr::across(dplyr::all_of(par_tr$Z_cols), ~ dplyr::first(.x)),
                obs_T = max(.time, na.rm = TRUE),
                Delta = {
                  i_last <- which.max(.time)
                  as.integer(.status[i_last] == max(.status, na.rm = TRUE))
                },
                .groups = "drop"
              )
            ipcw_fit_k <- .WA_ipcw_fit(tr_df, method = ipcw, ipcw_formula = ipcw_formula)
            
            # PE on TEST
            PE_k <- WA_PE(
              fit = fit_k, formula = formula, data_test = test, id = id,
              w_recur = w_recur, w_term = w_term,
              ipcw_fit = ipcw_fit_k, tau_grid = tau_grid
            )
            PE_sum <- PE_sum + PE_k
            
            if (verbose) { cat("done.\n"); flush.console() }
            bump()
          }
          
          results[[idx]] <- data.frame(
            basis = bs, degree = deg, n_int = nk, link = lnk,
            PE = PE_sum, stringsAsFactors = FALSE
          )
          idx <- idx + 1L
        }
      }
    }
  }
  
  if (verbose) cat("\nAll folds complete.\n")
  
  out <- do.call(rbind, results)
  rownames(out) <- NULL
  out[order(out$PE), ]
}

